\chapter{Referencial Teórico}

\iffalse
\section{Qualidade de Software}


\section{Métricas de qualidade OO}

CKsuite
em quê foi baseado essas metrica.
quais são os métricas e como interpreta-las
\fi

\section{Princípios e Padrões de Projetos}

Desenvolver software orientado a objetos é um desafio. Criar uma representação
computacional de uma faceta da realidade em que seus constituintes trabalhem de
forma horminiosa para atingir as necessidades que o software se propõe a
atender requer experiência, conhecimento do domínio do problema e um processo de
análise e projeto. Apesear de existir várias abordagens para se conceber um
sistema orientado a objetos\cite{evans2004ddd},\cite{gomma11} um sistema bem
contruído apresetam características fundamentais. Coesão, acoplamento etc
\cite{demarco},\cite{page-jones}.


Um padrão dentro do contexto de estudo deste presente trablho pode ser definido
como uma técnica efetiva cuja a sua aplicabilidade é aceita e difundiida dentro
de uma área de conhecimento com a intenção de atingir um
objetivo\cite{MetskerWake06}.

Em densenvolvimento de software o catálogo mais difundido de padrões de projetos
orientado a objetos é elaborado por \citeonline{gof} contendo um total de 23
padrões formalmente documentados que acumulam experiências bem sucedidas 
diversos sistemas. Esses padrões tem a seguinte classificação:


\begin{description}
\item[Criacionais] Padrões que definem como criar novas instâncias de classes.
\item[Estruturais] Foca na estruturação das classes e objetos.
\item[Comportamentais] Definem como as classes e objetos interagem entre si e
suas responsabilidades.
\end{description}

Com o intuito de documentar os padrões de projetos de forma objetiva para
facilitar o aprendizado dos mesmos, a comparação e escolha do padrão a ser
aplicado, \citeonline{gof} elabora um modelo que descreve as seguintes
caracteristicas para cada padrão:

\begin{description}
\item[Nome e Classificação]
\item[Intenção]
\item[Também conhecido como]
\item[Motivação]
\item[Aplicabilidade]
\item[Estrutura]
\item[Participantes]
\item[Collaborations]
How the participants collaborate to carry out their responsibilities.
\item[Consequences]
How does the pattern support its objectives? What are the trade-offs and results
of using the pattern? What aspect of system structure does it let you vary inde-
pendently?
\item[Implementation]
What pitfalls, hints, or techniques should you be aware of when implementing
the pattern? Are there language-specific issues?
\item[Sample Code]
Code fragments that illustrate how you might implement the pattern in C++ or
Smalltalk.
\item[Known Uses]
Examples of the pattern found in real systems. We include at least two examples
from different domains.
\item[Related Patterns]
\end{description}

%argumentação
Analisando a forma como um padrão de projeto é concebido definindo papéis de
cada elemento participante e como eles interagem entre se podemos concluir que
os padrões de projeto promovem maior coesão, melhor separação de interesses e
baixo acoplamento no sistema.


\section*{Model View Controller}

O padrão de projeto Model-View-Controller foi apresentado por
\citeonline{krasnerPope1988} como uma forma de promover a reusabilidade e
plugabilidade no ambiente de programação Smalltalk-80 capturando de forma
orientada a objetos as interações do usuário e a interface do programa através
de três componentes:

Models - É o compoente constituído de uma composição de classes que implementam
as regras de negócio referentes as funcionalidades que o programa provê contendo
estruturas de dados variadas, atende mensagens da view requisitando seu estado e
mensagens do controller para mudar seu estado.

Views - Representação específica de um model na interface com o usuário
responsável por todo a manipulação visual, recuperando um estado do
model e exibindo os dados, podendo ser composta por sub-views e ser parte de
views mais complexas.

Controllers - Interpreta a as ações do usuário provenientes de um dispositivo de
entrada(Teclado, Mouse) alterando estado da view ou do model.

\citeonline{krasnerPope1988} descreve a estrutura do MVC onde a view tem seu
controller exclusivo mantendo uma dependência cíclica entre ambos e tanto a view
quanto o controller tem referências diretas para o model por meio de atributos
de classe porém o model não deve conhecer seus respectivos pares de
View-Controller para promover mais reuso de código e encapsulamento do model. As
alterações do estado do model são feitas na maioria das vezes pelo controller, e
o model é responsável por notificar todas as views que o representa para que
se atualizem refletindo o novo estado. No caso de um model ser usado por vários
pares de View-Controller as mensagens de notificação de um novo estado do model
podem ser parametrizadas assim cada view pode verificar se a alteração é de seu
interesse. Segundo \citeonline{Fowler:2002:PEA} ``Of these the separation of presentation
from model is one of the most fundamental heuristics of good software design''.

O controller poderia ser o responsável por publicar as alterações no estado do
model devido sua relação direta com o mesmo, mas em casos onde o model é
alterado por outro componente que não é um dos controladores que os utilizam, é
necessário que o model conheça as views que devem ser notificados do novo
estado. Para que essas alterações de estado sejam propagadas a view e o
controller são registrados como dependentes de seu model. O padrão é descrito
dentro do contexto no qual o surgiu levando em consideração caracteristicas
espefíficas da  linguagem de programação que dão suporte à implementação dos
três componentes como por exemplo o gerenciamento dos objetos que são
dependentes do model definido na classe Objet que o model deve extender. A
Figura \ref{mvc_seq} esclarece a interação entre os componetes.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{img/mvc_seq.png}
	\caption{Diagrama de Sequência do MVC/Fonte: Próprio Autor}
	\label{mvc_seq}
\end{figure}

\citeonline{gof} cita \citeonline{krasnerPope1988} fazendo uma análise dos
objetos que compõem o MVC relacionando-os com outros padrões de proejtos. O
desacoplamento entre a view e o model e a propagação das mudanças de estado no
model para os objetos regitrados como dependentes do model pode ser descrico
como uma implementação do padrão Observer. A hierarquia de views é um exemplos
de Composite pois uma view pode ser constituída por sub-views para compor views
complexas. O Strategy é aplicando ao controller que encapsula o algoritmo que
vai alterar a view ou o model podendo ser substituído por por um outra
implementação que deixa de responder às interações com o usuário.




\section*{MVP}

Onde Quando surgiu

Necessidades 

Model

View 

Presenter

Diferencas entre o mvc.

\section*{Android}
 
Historia caracteristicas
Arquitetura.

Componentes
	Activity
	service
	broadcastReceiver
	ContentProvider



Como DP resolvem problemas, seguir linha de raciocinio para aplicar padrões em
android.


Analise do componente Activity, UI Thread, hieráriquia de herança e algumas
funcionalidades que dependem da activity e como isso interfere na aplicação do
padrão(Por experiência confirmo que é negativa). mostrar exemplo de uma view em
lista para smartphone e outra para tablet com grid usando o mesmo modelo

Experimentos

activity - controller+async task - listeners,
activity - controller+async task - observer pattern,
activity - controller+async task - localbroadcast
activity - controller+async task - Messages
Activity+Fragment


