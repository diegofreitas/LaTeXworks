\chapter{Referencial Teórico}

\section{Princípios e Padrões de Projetos}


Desenvolver software orientado a objetos é um desafio. Criar uma representação
computacional de uma faceta da realidade em que seus constituintes trabalhem de
forma harmoniosa para atingir as necessidades que o software se propõe a
atender requer experiência, conhecimento do domínio do problema e um processo de
análise e projeto. Apesar de existir várias abordagens para se conceber um
sistema orientado a objetos\cite{evans2004ddd},\cite{gomma11} um sistema bem
contruído apreseta características fundamentais como alta coesão e
baixo acoplamento.

A Coesão é uma característica de um componete de software que se refere ao grau
de relacionamento entres os menbros desse componente. No contexto de uma classe,
é levado em consideração as relações entre os métodos e atributos. Classes com
coesão baixa demonstram grande complexidade pois os atributos e métodos que não
se relacionam indicam que a classe tem muitas responsablidades.

O acoplamento descreve as dependências entre componetes. Quanto maior a
quantidade dessas dependências entre classes, mais complexo ela se torna, pois
dificulta  alterações na classe. Além disso, o acoplamento aumenta o risco de
uma classe ser afetada devido à alterações em suas dependências.

Um padrão, dentro do contexto de estudo deste trabalho pode ser definido
como uma técnica efetiva cuja a sua aplicabilidade é aceita e difundiida dentro
de uma área de conhecimento com a intenção de atingir um
objetivo\cite{MetskerWake06}.

Em desenvolvimento de software, o catálogo mais difundido de padrões de projetos
orientado a objetos é elaborado por \citeonline{gof}, contendo um total de 23
padrões formalmente documentados que acumulam experiências bem sucedidas em
diversos sistemas. Esses padrões têm a seguinte classificação:

\begin{description}
\item[Criacionais] Padrões que definem como criar novas instâncias de classes.
\item[Estruturais] Foca na estruturação das classes e objetos.
\item[Comportamentais] Definem como as classes e objetos interagem entre si e
suas responsabilidades.
\end{description}

%argumentação
Analisando a forma como um padrão de projeto é concebido, com uma definição
dos papéis de cada elemento participante e como eles interagem entre si,
pode-se concluir que o uso dos padrões de projeto promove maior coesão, melhor
separação de interesses e baixo acoplamento no sistema. Todas essas
características são muito importantes e contribuem para um software de melhor
qualidade.


%Melhorar isso

%Linkar com as metricas, mostrar relação metricas e padroes

\section{Métricas de qualidade OO}
\label{sec:metrics}

Com o advento de novas técnicas de desenvolvimento de software é necessário
obter informações do impacto dessas inovações nos resultados de um projeto. Com
esse objetivo \citeonline{cksuite} elaboram um conjunto de métricas para
mensurar a qualidade de sistemas desenvolvido usando o paradigma orientado a objetos que
não se limitasse a uma linguagem de programação, fácil de coletar e com forte
embasamento teórico na ontologia de bunge\footnote{}. This model is used to analyze
some static and dynamic properties of an information system and to examine the
question of what constitutes a good decomposition of an information
system\cite{WandWeber}As métricas são:

%Bunge’s ontology has
%considerable appeal for 00 researchers since it deals with the
%meaning and definition of representations of the world, which
%are precisely the goals of the object oriented approach [32]



\begin{description}
\item[Acoplamento entre objetos (CBO)] Número de classes que ela depende por
meio da relação de composição. Uma classe está acoplada a outra quando o método
de um classe invoca o método de uma variável de instância de outra classe que
gera uma dependência entre essas classes. Quanto maior essa dependência, mais
difícil é reutilizar esses componetes em outras partes do sistema, além do
aumento do risco de efeitos colaterais ocorrerem ao modificar uma classe
altamente acoplada.
\item[Ausência de coesão dos métodos(LCOM)] Usado para avaliar a coesão de uma
classe através da similaridade entre seus métodos. Um método tem similaridade
com outro quando a intercessão entre os conjuntos de atributos usados por ambos
os métodos tem cardinalidade maior que zero. LCOM mostra esses conjuntos nulos
indicando os métodos que usam esses atributos deveriam ser implementados em
outra classe. Essa similaridade expressa a coesão da classe.
\item[Profundidade na árvore de herança (DIT)] Nível de uma classe na
hierárquia de herança. Reflete o número máximo de elementos pai dentro da aŕvove
de classes até a raiz, o que aumenta a complexidade conforme a quantidade de
elementos envolvidos se eleva, diminuindo a previsibilidade do comportamento da
classe com vários métodos e atributos sendo herdados, principalmente com o uso
de sobrecarga de métodos.
\item[Métodos por Classe (WMC)] Serve para expressar o nível de complexidade de
uma classe basseado no número de métodos que ela possui. Isso afeta o esforço de
manutenção da classe, além de impactar nas classe filhas que herdarão esses
métodos. Também é um indicativo de que a classe tem métodos específicos
dificultando o seu reuso.
\item[Número de classes filhas (NOC)] Número de subclasses imediatas de uma
classe. Essa medida é um indicativo de mau uso de herança conforme seu valor
aumenta e mostra o impacto que uma classe pode ter no sistema requerendo maior
atenção e testes.
\item[Response sets for Class (RFC)] Quantidade de métodos que são executados
quando um objeto recebe uma mensagem, incluindo os métodos de outras classes. 
\end{description}

Todas essas métricas tem uma relação inerente com a coesão e acoplamento dos
objetos, sendo uma forma confiável para a análise da qualidade em sistemas
orientados a objetos. Os aplicativos desenvolvidos para a plataforma android são
escritos usando a linguagem de programação Java que emprega esse paradigma de
desenvolvimento, o que justifica o uso das métricas de \citeonline{cksuite} para
validação dos projetos orientados a objetos.

\section{Model View Controller}

O padrão Model View Controller surgiu como uma solução genérica para que
usuários de uma sistema de planejamento manipulem dados complexos
\citeonline{Reenskaug:1979}. Posteriormente, \citeonline{krasnerPope1988}
implementam um framework MVC para o ambiente gráfico da linguagem de programação
Smalltalk-80 como uma forma de promover a reusabilidade e plugabilidade.

Segundo \citeonline{Reenskaug:1979} o principal objetivo do MVC
``\ldots é representar o modelo mental do usuário de um espaço de informações
relevantes e permitir que o usuário inspecione e altere esta
informação.''(tradução livre).
Esse modelo mental é como o usuário percebe o dominio do problema que está inserido no qual executará suas atividades sobre dados de seu interesse. Para que o usuário de um sistema de
informação possa interagir com a represetação computacional  de seu modelo
mental três componetes são definidos:

Models - É o compoente constituído de uma composição de classes que implementam
as regras de negócio referentes as funcionalidades que o programa provê,
representa o  conhecimento que o usuário tem e como manipula-lo. Atende
mensagens da view requisitando seu estado e mensagens do controller para mudar
seu estado,

Views - Representação específica de um model na interface com o usuário, é 
responsável por todo a manipulação visual, recuperando um estado do model e
exibindo os dados, podendo ser composta por sub-views e ser parte de views mais
complexas.

Controllers - Interpreta a as ações do usuário provenientes de um dispositivo de
entrada(Teclado, Mouse) alterando estado da view ou do model.




\citeonline{krasnerPope1988} descrevem a estrutura do MVC onde a view tem seu
controller exclusivo mantendo uma dependência cíclica entre ambos. Tanto a View
quanto o Controller tem referências diretas para o model por meio de atributos
de classe, porém, o model não deve conhecer seus respectivos pares de
View-Controller para promover maior reuso de código e encapsulamento do model.
As alterações do estado do model são feitas na maioria das vezes pelo controller, e
o model é responsável por notificar todas as views que o representa para que
se atualizem refletindo o novo estado. No caso de um model ser usado por vários
pares de View-Controller as mensagens de notificação de um novo estado do model
podem ser parametrizadas assim cada view pode verificar se a alteração é de seu
interesse. 

Segundo \citeonline{Fowler:2002:PEA} ``\ldots esta separação da
apresentação e modelo é uma das mais fundamentais herísticas de bom projeto
de software''(tradução livre).
O controller poderia ser o responsável por publicar as alterações no estado do
model devido sua relação direta com o mesmo, mas em casos onde o model é
alterado por outro componente que não é um dos controladores que os utilizam, é
necessário que o model conheça as views que devem ser notificados do novo
estado. Para que essas alterações de estado sejam propagadas a view e o
controller são registrados como dependentes de seu model. O padrão é descrito
dentro do contexto no qual o surgiu levando em consideração caracteristicas
espefíficas da  linguagem de programação que dão suporte à implementação dos
três componentes como por exemplo o gerenciamento dos objetos que são
dependentes do model definido na classe Objet que o model deve extender. A
Figura \ref{mvc_seq} esclarece a interação entre os componetes.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{img/mvc_seq.png}
	\caption{Diagrama de Sequência do MVC/Fonte: Próprio Autor}
	\label{mvc_seq}
\end{figure}

\citeonline{gof} cita \citeonline{krasnerPope1988} fazendo uma análise dos
objetos que compõem o MVC relacionando-os com outros padrões de proejto
descritos em seu catálogo.
O desacoplamento entre a View e o Model, somado à propagação das mudanças de
estado no model para os objetos regitrados como dependentes do model pode ser
descrito como uma implementação do padrão Observer. O padrão Observer define uma
estrutura em que um componente que precisa publicar mudanças em seu estado, detém a
referência para uma lista de objetos a serem notificados. A hierarquia de views
é um exemplos de Composite pois uma view pode ser constituída por sub-views para
compor views complexas. No Composite  um conjunto de componentes podem ser
tratadas de forma encapsulada onde cada implementa as mesmas abstração. O padrão
Strategy define uma abstração cuja as implementações podem ser trocadas de
acordo com algum critério, esse conceito pode ser aplicado ao controller que
encapsula o algoritmo que vai alterar a View e o Model, permitindo sua
substituíção por uma outra implementação que deixa de responder às interações
com o usuário.

Segundo \citeonline{krasnerPope1988} o Model ``\ldots pode ser simples como
um valor numério inteiro (como o modelo de um contador) ou um valor literal
(como o modelo de um editor de texto), ou pode ser um objeto
complexo''(tradução livre).
O model pode ser implementado usando o pardrão Facade para simplificar as
interações com o Model dependendo da complexidade do domínio que ele
representa.

\section{Model View Presenter}

O MVP é um modelo de programação para implementação de interfaces com o usuário
desenvolvido como um framework para C++ e Java, criado por uma subsidiária da
IBM chamda Taligent,Inc. Este padrão é baseado no MVC e descreve vários componentes que tem as
responsabilidades de como gerenciar os dados da aplicação e como o usuário
interage com esses dados, tendo como objetivo promover o encapsulamento do Model
, reuso de lógica de negócio e o polimorfismo da View.

\begin{description}
  \item[Model] Tem as mesmas responsabilidades que o Model definido pelo MVC.
  \item[Selections] - Abstração para selecionar um subconjunto dos dados
  existentes no model.
  \item [Commands] Representa as operações a serem executadas sobre uma
  Selection do Model.
  \item [View] Responsável por exibir o model assim como no MVC.
  \item [Interactor] Mapeia os interações do usuário na view como eventos do
  mouse.
  \item [Presenter] O papel do presenter é interpretar o eventos iniciados pelo
  usuário executando a lógica de negócio correspondente implementada em um
  command para manipular o model \cite{Potel96mvp}.
\end{description}


Os conceitos do MVP são descritos em \citeonline{Potel96mvp} de forma genérica
permintindo interpretações para uma implementação efetiva.
\citeonline{twisttriad:2000} descreve a implementação de um framework para
Dolphin Smalltalk\footnote{Implementação da Linguagem de programação Smalltalk - 
\url{http://www.object-arts.com}} adotando os conceitos do MVP onde salienta que
a maioria dos sistemas operacionais com ambiente gráfico fornece um conjunto de
componentes (Widgets) no qual está contido a responsabilidade do controller.A
maior parte do comportamento do caso com o usuário é implementada no
Presenter que está diretamente associado à View.

Ainda acerca das responsabilidades do Presenter, \citeonline{fowler:ui} descreve
o que é chamado de Passive View, onde toda a lógica do comportamento da view é
implementado no presenter deixando a view enxuta com o intuito de isolar ao
máximo a API gráfica do resto da aplicação. Dessa forma o model não se comunica
com a view por meio do observer pattern, sendo que a view séra atualizada pelo
presenter como pode ser observado na Figura~\ref{fig:mvp_passive_view}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{img/mvp_passive_view.png}
	\caption{Passive View/Fonte: Próprio autor}
	\label{fig:mvp_passive_view}
\end{figure}

MVP se adequa melhor as apis gráficas existentes e define de forma mais clara os
componetes necessários para desenvolver uma aplicação, sendo o ponto de maior
discussão reside em quais os limites das responsabilidades no que tange a
mediação do Model e a View por parte do Presenter.

\section{Framework Android}
 

O android é um sistema operacional baseado no linux mantido pela Google para
ser embarcado em dispositivos podendo ser aplicado em carros, televisão, placas
controladoras mas seu destaque é a utilização em smartphones e
tablets, que é o foco deste trabalho. A plataforma é contituída por API's e
frameworks tendo em sua base o sistema operacional e seus drivers seguido da
máquina virtual que executa os aplicativos android e bibliotecas auxiliares e
aplicativos básicos como é demonstrado na figura \ref{android_stack}.

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{img/android_stack.png}
	\caption{Android Stack/Fonte: Learning Android}
	\label{android_stack}
\end{figure}

Para desenvolvimento é usado a api disponível no sdk que define
os blocos de construção de um aplicativo, a saber:

\begin{description}
  \item[Activity] Representa uma atividade que o usuário executa no aplicativo
  em um determinado momento. É um agregador de componetes visuais e responde à
  interações do usuário.
  \item[Fragment] Representa uma parte de interface com o usuário em uma
  Activity.
  \item[Service] Responsável por executar uma operação sem interface gráfica
  indicado para processamentos longos como por exemplo a execução de uma música
  ou download de de arquivos.
  \item[Broadcast Receiver] Implementação do padrão publish/subscribe 
  \item[Content Provider] Usado para expor dados de uma aplicativo para outros
  aplicativos. Os dados podem ser provenientes de qualquer forma de
  armazenamento como um arquivo ou banco de dados.
  \item[ApplicationContext] Representa a aplicação em execução provendo acesso
  a recursos.
  \item[AsyncTask] Usado para implementar computação paralela evitando o uso da
  linha de execução principal do aplicativo que é respoonsável por tratar a
  interações com o usuário.
\end{description}

Com base nos componentes de framework e literatura revisada é possível fazer
uma análise dos mesmos e projetar uma camada de apresentação utilizando o padrão
MVP para ser usada como referência de implementação a ser aplicada.